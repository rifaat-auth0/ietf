<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IETF" docName="draft-yusef-oauth-nested-jwt-07" category="std" ipr="pre5378Trust200902" obsoletes="" updates="" xml:lang="en" sortRefs="true" symRefs="true" tocInclude="true" version="3" consensus="true">
  <!-- xml2rfc v2v3 conversion 3.12.10 -->
  <!-- Generated by id2xml 1.5.0 on 2020-04-06T20:09:19Z -->
	<front>
    <title abbrev="JWT Embedded Tokens">JSON Web Token (JWT) Embedded Tokens</title>
    <seriesInfo name="Internet-Draft" value="draft-yusef-oauth-nested-jwt-07"/>

    <author fullname="Rifaat Shekh-Yusef" initials="R." surname="Shekh-Yusef">
      <organization>Okta</organization>
      <address>
        <postal>
          <street>Ottawa, Ontario, Canada</street>
        </postal>
        <email>rifaat.s.ietf@gmail.com</email>
      </address>
    </author>
 
    <author fullname="Dick Hardt" initials="D." surname="Hardt">
      <organization>Hellō</organization>
      <address>
        <postal>
          <street>Seattle, Washington, USA</street>
        </postal>
        <email>dick.hardt@gmail.com</email>
      </address>
    </author>

    <author fullname="Giuseppe De Marco" initials="G." surname="De Marco">
      <organization>Dipartimento per la trasformazione digitale della Presidenza del Consiglio dei Ministri</organization>
      <address>
        <postal>
          <street>Italy</street>
        </postal>
        <email>giuseppe.demarco@teamdigitale.governo.it</email>
      </address>
    </author>

    
    <date day="26" month="Dec" year="2022"/>
    <workgroup>OAuth Working Group</workgroup>
    <abstract>
      <t>
       	This specification defines a mechanism for embedding tokens into a JWT token. 
        The JWT token and the embedded tokens are issued by different issuers.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor="Intro" numbered="true" toc="default">
      <name>Introduction</name>
      	<t>
        JWT is a mechanism that is used to transfer claims between two parties across security domains. 
        There are a number of use cases that need to embed tokens into another JWT token.
      	</t>
      	<t>
       	This specification defines a mechanism for embedding tokens into a JWT token. 
        The JWT token and the embedded tokens are issued by different issuers.
      	</t>
    	<t>
        Such a mechanism allows for a proper auditing trail that allows the Resource Server to identify who 
        accessed what resource and on behalf of whom. In some cases, this allows the service consuming 
        such a token to present some of the information contained in the nested token or claims to the 
        end user in real-time. In addition, in some cases, this allows the Resource Server to apply 
        authorization policies based on who requested the access to the resource and on behalf of whom 
        is the request.
    	</t>
	    
      <section anchor="sect-1.1" numbered="true" toc="default">
        <name>Terminology</name>
        <t>
   	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   	"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   	document are to be interpreted as described in <xref target="RFC8174" format="default"/>.</t>
    </section>

	    
	    
    </section>
    <section anchor="use-cases" numbered="true" toc="default">
      <name>Use Cases</name>
      <t>
        The following are few use cases that might benefit from such a concept:
      </t>

        <section anchor="stir" numbered="true" toc="default">
          <name>STIR</name>
          <t>
   <xref target="RFC8225" format="default"/> defines a PASSporT, which is a JWT, that is used to verify
   the identity of a caller in an incoming call.</t>
          <t>
   The PASSporT Extension for Diverted Calls draft <xref target="STIR" format="default"/> uses a nested
   PASSporT to deliver the details of an incoming call that get
   redirected.  An authentication service acting for a retargeting
   entity generates new PASSporT and embeds the original PASSporT inside
   the new one.  When the new target receives the nested PASSporT it
   will be able to validate the enclosing PASSporT and use the details
   of the enclosed PASSporT to identify the original target.
          </t>
          <t>
   In this case, the original JWT is issued by the calling service, and the new enclosing 
   JWT is issued by the retargeting service.
          </t>
        </section>

  <section anchor="nsm" numbered="true" toc="default">
  <name>Network Service Mesh (NSM)</name>
  <t>
   Network Service Mesh [NSM] is a mechanism that maps the concept of a
   service mesh in Kubernetes to L2/L3 payloads.
  </t>
  <t>
   NSM GRPS messages may pass through multiple intermediaries, each of
   which may transform the message.  Each intermediary is expected to
   create its own JWT token, and include a claim that contains the JWT it
   received with the message it has transformed.
  </t>
  <t>
   In this case, the original JWT is issued by the entity sending the initial message, 
   and the new enclosing JWT is issued by the intermediate entity.
  </t>
  </section>
  
  
  <section anchor="same-subject" numbered="true" toc="default">
  <name>Multiple Issuers for same Subject</name>
  <t>
     A JWT may have embedded claims from one or more separate Issuers. 
  </t>
  <t>
  An ID Token may have identity claims from independent issuers such as DOB and a professional accreditation.
  </t>
  </section>
    
  <section anchor="multiple-audiences" numbered="true" toc="default">
  <name>Multiple tokens for multiple resources</name>
  <t>
     A JWT may embeds tokens for different audiences and scopes. 
  </t>
  <t>
  An Authorization Server issues a JWT Token that contains multiple tokens. 
  Each token has a specialized set of attributes and values.
  The tokens can be used by the client to consume protected resources or to obtain access tokens through 
  a token exchange mechanism, over different domains, releasing the minimum possible number 
  of information, related on the main subject, necessary for the operation. 
  </t>
  </section>

    </section>




    <section anchor="embedded-token-request-response" numbered="true" toc="default">
      <name>Authorization Request and Response</name>

    <t>  
    This section describes the mechanism to request an existing token or tokens to be embedded in a new token. The mechanism 
    defines a new grant type embedded-tokens for this purpose.
    </t>

    <section anchor="embedded-token-request" numbered="true" toc="default">
      <name>Authorization Request</name>
      <t>
        When a client receives a token, and it needs to transform or/and enhance the permissions of the token, 
        the client will send a token request to the AS, and include the received token or tokens to be embedded in the newly 
        issued token that contains the transformed token details or permissions.
      </t>

      <t>
        The Client requests a token by sending an authorization request to the authorization server’s token endpoint and include
        the following parameters in a JSON payload:
      </t>


    <dl newline="true">
      <dt>grant_type (REQUIRED)</dt>
      <dd>Carries the new grant type to indicate to the token endpoint that the provided token(s) to be embedded 
      into the newly issued token. The parameter value MUST be urn:ietf:params:oauth:grant-type:embedded-tokens</dd>

      <dt>tokens (REQUIRED)</dt>
      <dd>An array of objects, where each object represents a token that contains the “type” claim and either the “token” claim, 
      or the “digest" and “jti” claims, as defined in section 4 of this specification.</dd>
    </dl>

      <t>
      The request MAY include any of the following parameters, defined in Section 2.1 of RFC8693: resource, audience, scope, 
      and requested_token_type. 
      </t>


      <t>
      The following is an example of this new token request:
      </t>

      <artwork name="" type="" align="left" alt=""><![CDATA[
      
 POST /token
 Host: as.example.com
 Content-Type: application/json
 
 {
    "grant_type": "urn:ietf:params:oauth:grant-type:embedded-tokens",
    "requested_token_type": "urn:ietf:params:oauth:token-type:access_token"
    "tokens": [
      {
        "type": "urn:ietf:params:oauth:token-type:access_token",
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
                  eyJzdWIiOiIyMzQ1Njc4OTAxIiwibmFtZSI6IkFsZXggRG9lIiwia
                  WF0IjoxNTE2MjM5MDIyLCJqdGkiOiJYRkVYYlNDMHhpTXUifQ.
                  wyycbcY9i0U5YldltNhp4WbM-gF3Q1-jtnc-Wvzyxcg"
      }
    ]
 }

]]></artwork>

      <t>
      The following is the decoded example embedded token in the above example:
      </t>

      <artwork name="" type="" align="left" alt=""><![CDATA[
{
  "alg": "HS256",
  "typ": "JWT"
}
.
{
  "sub": "2345678901",
  "name": "Alex Doe",
  "iat": 1516239022,
  "jti": "XFEXbSC0xiMu"
}      

]]></artwork>

    </section>


      <section anchor="embedded-token-response" numbered="true" toc="default">
      <name>Authorization Successful Response</name>
    
      <t>
      Before issuing the requested token, the authorization server MUST ensure that the request is 
      valid and that the embedded token(s) provided in the subject_token is coming from a trusted and approved entity
      </t>

      <t>
      In the case that the authorization server validated and approved the request, the authorization server 
      responds to the above request with the standard token exchange response, as defined in section 
      2.2.1 of [RFC8693].
      </t>

      <t>
      The type of token issued is as specified in the requested_token_type parameter, if provided. 
      Otherwise, the type of token issued is at the discretion of the authorization server.
      </t>

      <section anchor="embedded-token-by-value" numbered="true" toc="default">
      <name>Embedded Tokens By Value</name>
      <t>
      The authorization server will typically embed the provided tokens directly into the newly issued token, 
      when there are no concerns around the size of the new token with the embedded tokens.
      </t>

      <t>
      The following is an example for a JWT token with an embedded token: 
      </t>
      <artwork name="" type="" align="left" alt=""><![CDATA[
{
  "alg": "HS256",
  "typ": "JWT",
}
.
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "tokens": [
     {
        "type": "urn:ietf:params:oauth:token-type:access_token",
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
                  eyJzdWIiOiIyMzQ1Njc4OTAxIiwibmFtZSI6IkFsZXggRG9lIiwia
                  WF0IjoxNTE2MjM5MDIyLCJqdGkiOiJYRkVYYlNDMHhpTXUifQ.
                  wyycbcY9i0U5YldltNhp4WbM-gF3Q1-jtnc-Wvzyxcg"
     }
   ]
}

]]></artwork>

      </section>

      <section anchor="embedded-token-by-reference" numbered="true" toc="default">
      <name>Embedded Tokens By Reference</name>
      <t>
      In some cases, embedding the tokens into the JWT directly might cause the token size to become too large. 
      In this case, instead of embedding the tokens, the AS will embed a hash of the token(s) and its associated 'jti' claim(s). 
      This allows the Client to send these tokens directly to the RS with the newly issued JWT, to allow the RS to validate that the 
      tokens are indeed associated with this new issued JWT.
      </t>

      <t>
      The following is an example for a JWT token with a reference to the token: 
      </t>

<artwork name="" type="" align="left" alt=""><![CDATA[
{
  "alg": "HS256",
  "typ": "JWT",
}
.
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "tokens": [
    {
      "type": "urn:ietf:params:oauth:token-type:access_token:reference",
      "digest": 
      {
        "alg": "sha-256",
        "hash": "68e439fd95964da902a8654d47c51d6bc0a7791ea9895173989b263374a9a125"
      }
      "jti": "XFEXbSC0xiMu"
    }
  ]
}

]]></artwork>


      </section>

      </section>

      <section anchor="embedded-token-error-response" numbered="true" toc="default">
      <name>Authorization Error Response</name>
    
      <t>
      If the authorization fails to validate the embedded token, then the authorization server MUST 
      construct an error response, as specified in section 5.2 of RFC6749. The value of the error 
      parameter MUST be invalid_embedded_token error code.
      </t>

      <t>
      The authorization server MAY include additional information regarding the reasons for the error using 
      the error_description as discussed in Section 5.2 of [RFC6749].
      </t>
      </section>

    </section>

    <section anchor="jwt-claims" numbered="true" toc="default">
      <name>JSON Web Token Claims</name>

    <t>
    This section defines the new claims that will be used to represent the embedded tokens. 
    It defines one top-level claim, "tokens" claim, and 3 sub claims under that, 'type', "token", 
    and "digest" claims.
    </t>

    <section anchor="tokens-claim" numbered="true" toc="default">
      <name>"tokens" Claim</name>

    <t>
    The "tokens" claim is an array of objects, where each object represents a token, that contains 
    the “type” claim and either the “token” claim, or the “digest" and “jti” claims.
    </t>

    <section anchor="type-claim" numbered="true" toc="default">
      <name>"type" Claim</name>
    <t>
    The "type" claim is used to indicate the type of embedded token, which takes one of the values defined in Section 3, RFC8693.
    </t>
    </section>

    <section anchor="token-claim" numbered="true" toc="default">
      <name>"token" Claim</name>
    <t>
    The "token" claim is used to hold the details of the embedded token.
    </t>
    </section>

    <section anchor="token-digest" numbered="true" toc="default">
      <name>"digest" Claim</name>
    <t>
    The "digest" claim is an object that is used to hold the hash of the token, to be used to reference the 
    token instead of embedding it directly in the new JWT.ß
    </t>

    <t>The object contains the following two claims:</t>

    <section anchor="token-alg" numbered="true" toc="default">
      <name>"alg" Claim</name>
    <t>
    Holds the algorithm used to hash the token. By default this is "sha-256".
    </t>
    </section>

    <section anchor="token-hash" numbered="true" toc="default">
      <name>"hash" Claim</name>
    <t>
    Holds the hash value of the token using the algorithm defined in the "alg" claim.
    </t>
    </section>

    </section>

    </section>

    
    </section>


    <section anchor="sect-7" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>
      The entity handling the incoming authorization request MUST validate the token and 
      ensure that it is coming from a trusted entity, before attempting to embed that into a newly issued JWT.
      </t>
    </section>
    <section anchor="sect-8" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>
   TODO</t>
    </section>
    <section anchor="sect-9" numbered="true" toc="default">
      <name>Acknowledgments</name>
      <t>
   TODO</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC7519" target="https://www.rfc-editor.org/info/rfc7519" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml">
          <front>
            <title>JSON Web Token (JWT)</title>
            <author initials="M." surname="Jones" fullname="M. Jones">
              <organization/>
            </author>
            <author initials="J." surname="Bradley" fullname="J. Bradley">
              <organization/>
            </author>
            <author initials="N." surname="Sakimura" fullname="N. Sakimura">
              <organization/>
            </author>
            <date year="2015" month="May"/>
            <abstract>
              <t>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties.  The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7519"/>
          <seriesInfo name="DOI" value="10.17487/RFC7519"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author initials="B." surname="Leiba" fullname="B. Leiba">
              <organization/>
            </author>
            <date year="2017" month="May"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="RFC8225" target="https://www.rfc-editor.org/info/rfc8225" xml:base="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8225.xml">
          <front>
            <title>PASSporT: Personal Assertion Token</title>
            <author initials="C." surname="Wendt" fullname="C. Wendt">
              <organization/>
            </author>
            <author initials="J." surname="Peterson" fullname="J. Peterson">
              <organization/>
            </author>
            <date year="2018" month="February"/>
            <abstract>
              <t>This document defines a method for creating and validating a token that cryptographically verifies an originating identity or, more generally, a URI or telephone number representing the originator of personal communications.  The Personal Assertion Token, PASSporT, is cryptographically signed to protect the integrity of the identity of the originator and to verify the assertion of the identity information at the destination.  The cryptographic signature is defined with the intention that it can confidently verify the originating persona even when the signature is sent to the destination party over an insecure channel.  PASSporT is particularly useful for many personal-communications applications over IP networks and other multi-hop interconnection scenarios where the originating and destination parties may not have a direct trusted relationship.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8225"/>
          <seriesInfo name="DOI" value="10.17487/RFC8225"/>
        </reference>
        <reference anchor="RFC8693">
          <front>
            <title>OAuth 2.0 Token Exchange</title>
            <author fullname="M. Jones" initials="M." surname="Jones">
         </author>
            <author fullname="A. Nadalin" initials="A." surname="Nadalin">
         </author>
            <author fullname="B. Campbell" initials="B." surname="Campbell"/>
            <author fullname="J. Bradley" initials="J." surname="Bradley"/>
            <author fullname="C. Mortimore" initials="C." surname="Mortimore"/>
            <date month="October" year="2018"/>
          </front>
        </reference>
        <reference anchor="STIR">
          <front>
            <title>PASSporT Extension for Diverted Calls</title>
            <author fullname="J. Peterson" initials="J." surname="Peterson">
         </author>
            <date month="October" year="2018"/>
          </front>
        </reference>
      </references>
    </references>
  </back>
</rfc>